# Constitution

> 用途：这是项目的"宪法"，用于锚定所有 AI 交互的方向 🔧 使用方法：
> 
> 1. 首次填写后放入项目根目录
> 2. 每次开新 AI 对话时说："请先阅读 CONSTITUTION.md 了解项目背景"
> 3. 当 AI 建议偏离方向时，引用此文档

最后更新： 2026年2月1日 

---

## **项目愿景（不可动摇）**

**一句话描述**：

- 一个具备工业级代码质量、用于深度学习分布式系统设计的通用异步任务调度平台。

**解决的核心问题**：

- 统一解决分布式系统中的延时执行（订单超时）、周期调度（报表）和工作流编排问题。

**目标用户**：

1. **自己**：通过造轮子深度掌握分布式系统核心（Redis/锁/一致性），边学边做。
2. **面试官**：作为高展示价值的作品集，体现架构设计能力与工程规范。

---

## **核心不变量（不可违背的约束）**

| **编号** | **不变量** | **原因** |
| --- | --- | --- |
| C1 | **代码即文档 + 学习笔记**：每个模块顶部注释必须包含设计意图、核心算法和学习要点  | ① 面试时能快速讲清楚 ② 3 个月后的我还能看懂 |
| C2 | **无 ADR 不架构**：每个重大决策需有记录 | 训练架构思维，面试有据可依 |
| C3 | **测试安全网**：核心路径 (Enqueue/Consume) 必须有集成测试 | 保证重构时的心理安全，弥补当前测试短板 |
| C4 | **单体优先**：暂不引入 etcd/zk 等外部依赖 | 保持部署简单 (KISS原则)，聚焦核心逻辑实现 |

---

## **学习路线图（边做边学）**

| 阶段 | 技术点 | 学习方式 | 验收标准 |
|------|--------|----------|----------|
| **Phase 1** | Redis ZSet + Lua 原子性 | 改写 Lua 脚本时理解每一行 | 能解释为什么用 EVAL 而非 MULTI |
| **Phase 1** | gRPC 流式调用 | 实现 Retrieve 时对比单次/流式 | 能说出 stream 的适用场景 |
| **Phase 2** | 分布式锁 | 实现 Leader Election | 能手画 Redlock 算法流程 |
| **Phase 2** | CAP 理论 | 分析当前系统取舍 | 能说出队列在网络分区时的行为 |

> **学习检查点**：每完成一个 Phase，写一篇"我学到了什么"总结到 Daily Log

---

## **明确不做的事（Non-Goals）**

| 编号 | 不做的事 | 原因 |
| --- | --- | --- |
| N1 | **过度性能优化**：牺牲代码清晰度换取微小性能提升 | 学习价值 > 极限性能 |
| N2 | **复杂运维组件**：如 K8s Operator、Service Mesh | 此时重点是应用层架构，而非运维 |
| N3 | **过早的微服务拆分**：为了拆分而拆分 | 避免增加不必要的网络/调试复杂度 |

---

## **技术决策边界**

| **领域** | **我决定** | **AI可建议** |
| --- | --- | --- |
| **架构方向** | ✅ | ❌ |
| **新增依赖** | ✅ | ⚠️ 需我确认 |
| **数据模型** | ✅ | ⚠️ 需我确认 |
| **实现细节** | ⚠️ 我审查 | ✅ |
| **代码风格** | ⚠️ 我审查 | ✅ |

---

## **当前阶段聚焦**

**当前里程碑**：`v0.2.0` - API 闭环与质量夯实
**本阶段最重要的 3 件事**：

1. **API 补全**：实现 Delete (取消任务) 和 Retrieve (Worker拉取) 接口
2. **测试覆盖**：建立完整的集成测试框架，覆盖率目标 > 70%
3. **架构收敛**：规范化 Worker 实现，移除直接 Redis 依赖，改用 Service 接口

**本阶段明确不做**（即使看起来很诱人）：

- 引入 Cron 调度 (v0.3.0 再做)
- 引入 Prometheus/Grafana (v0.4.0 再做)
- 引入 Redis Cluster/HA

---

## **架构基线（变更需谨慎）**

| **层** | **当前选择** | **变更条件** |
| --- | --- | --- |
| **语言** | Go (1.25) | 不变 |
| **协议** | gRPC + Protobuf | 不变 |
| **存储** | Redis (单实例 ZSet+Hash) | 需写 ADR |
| **序列化** | JSON | 可在需要时优化为 Protobuf |

---

## **AI 交互准则**

### 当 AI 给出建议时，我会问：
1. ✋ **这符合当前阶段聚焦吗？** 不符合就延后
2. ✋ **这会引入新复杂性吗？** 复杂性需要证明价值
3. ✋ **这需要 ADR 吗？** 架构决策必须记录
4. ✋ **这是我想做的，还是 AI 觉得该做的？** 我主导方向

### 当 AI 帮我实现时，要求：
- **解释优先于实现**：先用一句话解释为什么这样做，再给代码
- **Trade-off 必讲**：每个技术选择都要说明放弃了什么
- **链接相关概念**：提到"分布式锁"时附上学习资源（如 DDIA 章节）
- **面试话术准备**：关键设计点给出"如何向面试官解释"的示例

### 学习触发词：
当我说"为什么"、"原理"、"深入"时，AI 应切换到**教学模式**而非直接给代码。

---

## **踩坑记录（持续更新）**

| 日期 | 问题 | 根因 | 学到的教训 |
|------|------|------|------------|
| 2026-01-11 | Worker 未调用 Ack，任务重复执行 | 不理解 visibility timeout | 消费模型必须显式确认 |
| _待补充_ | | | |

> **用途**：面试时讲"我遇到过的最难 bug"，体现解决问题能力

---

## **附录：关键文档索引**

| **文档** | **位置** | **用途** |
| --- | --- | --- |
| 架构设计 | **docs/ARCHITECTURE.md** | 系统组件与数据流 |
| 战略指南 | **docs/STRATEGIC_GUIDE.md** | 长期规划与里程碑 |
| API 参考 | **docs/API.md** | gRPC 接口使用指南 |
| 开发流程 | **docs/DEV_WORKFLOW.md** | 研发全流程规范 |
| ADR 目录 | `docs/adr/` | 架构决策记录 |
